---
title: How shadcn/ui examples work
date: "2024-05-11"
tags: post
---

I’m increasingly convinced that for developer-first tools, a really good docs experience is a durable, non-trivial advantage.

Part of this thesis is that Really Good Docs Experiences, in addition to having great information architecture and strong writing/prose, should be thought of less as ancillary content repositories that can be farmed out to whatever your helpdesk software is and more as important web-apps in their own right.

---

Every now and then, when a docs site does something cool I try to figure out _how_ they do it. Take [shadcn/ui](https://ui.shadcn.com/docs/components/card), for instance — how are all of these previews being generated based on Typescript? It’d be one thing if the components were HTML — you can just throw them into an iFrame — but clearly there’s something more complicated going on here.

Blessedly, these docs are open source, so I can find out exactly how. Let’s take that example `Notifications` card for example:

That page is being rendered in [MDX](https://github.com/shadcn-ui/ui/blob/main/apps/www/content/docs/components/card.mdx?plain=1); there’s a generic `ComponentPreview` component rendering it:

```jsx
<ComponentPreview
  name="card-demo"
  description="A card showing notifications settings."
/>
```

It looks like that [ComponentPreview](https://github.com/shadcn-ui/ui/blob/816b654f07b77c9c4c160ed42f0bb104592e3484/apps/www/components/component-preview.tsx#L21) component is just proxying out to some big `__registry__`:

```jsx
import { Icons } from "@/components/icons";

// ...

const Preview = React.useMemo(() => {
  const Component = Index[config.style][name]?.component;

  if (!Component) {
    return (
      <p className="text-sm text-muted-foreground">
        Component{" "}
        <code className="relative rounded bg-muted px-[0.3rem] py-[0.2rem] font-mono text-sm">
          {name}
        </code>{" "}
        not found in registry.
      </p>
    );
  }

  return <Component />;
}, [name, config.style]);
```

The component in the registry is [right here](https://github.com/shadcn-ui/ui/blob/main/apps/www/__registry__/default/example/card-demo.tsx), and that’s the exact source code that we see. But how is the registry aware of its constituents?

Because it’s autogenerated! There’s a [scripts/build-registry.ts](https://github.com/shadcn-ui/ui/blob/main/apps/www/scripts/build-registry.mts) file. This build file is _gnarly_ (understandably so), but at a high level it spits out this [massive export file](https://github.com/shadcn-ui/ui/blob/main/apps/www/__registry__/index.tsx):

```ts
    "card-demo": {
      name: "card-demo",
      type: "components:example",
      registryDependencies: ["card","button","switch"],
      component: React.lazy(() => import("@/registry/default/example/card-demo")),
      source: "",
      files: ["registry/default/example/card-demo.tsx"],
      category: "undefined",
      subcategory: "undefined",
      chunks: []
    },
```

And it finds the things to populate in that registry via a [manually-enumerated list of potential components](https://github.com/shadcn-ui/ui/blob/816b654f07b77c9c4c160ed42f0bb104592e3484/apps/www/registry/examples.ts#L173):

```ts
  {
    name: "card-demo",
    type: "components:example",
    registryDependencies: ["card", "button", "switch"],
    files: ["example/card-demo.tsx"],
  },
```

So, in sum, walking our way back to the final artifact:

1. `shadcn` has a big, manually-created list of example files (and associated dependencies/metadata.)
2. A build-time script analyzes that list and autogenerates both an augmented code snippet for that example file _and_ a big index that allows the site to import that snippet live.
3. A previewer component pulls in that autogenned snippet and its raw-source equivalent.
4. That previewer component is declared by an `mdx` file.

Nothing magical; nothing complex. But certainly _bespoke_.
